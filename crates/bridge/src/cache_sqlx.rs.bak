use sqlx::{SqlitePool, Row, query};
use anyhow::{Result, Context};
use nostr_sdk::{Event, EventId, PublicKey};

#[derive(Debug, Clone)]
pub struct EventCache {
    pool: SqlitePool,
}

#[derive(Debug, Clone)]
pub struct CachedEvent {
    pub id: String,
    pub pubkey: String,
    pub created_at: i64,
    pub kind: u16,
    pub tags: String,
    pub content: String,
    pub sig: String,
    pub group_name: Option<String>,
    pub stored_at: String,
}

#[derive(Debug, Clone)]
pub struct CacheStats {
    pub total_events: i64,
    pub by_kind: std::collections::HashMap<u16, i64>,
    pub by_group: std::collections::HashMap<String, i64>,
    pub recent_24h: i64,
}

impl EventCache {
    pub async fn new(db_path: &str) -> Result<Self> {
        let connection_string = format!("sqlite://{}?mode=rwc", db_path);

        let pool = sqlx::sqlite::SqlitePoolOptions::new()
            .max_connections(5)
            .connect(&connection_string).await
            .with_context(|| format!("Failed to connect to database: {}", db_path))?;

        // Enable WAL mode
        sqlx::query("PRAGMA journal_mode=WAL").execute(&pool).await?;
        sqlx::query("PRAGMA busy_timeout=5000").execute(&pool).await?;

        let cache = EventCache { pool };
        cache.init_schema().await?;

        Ok(cache)
    }

    async fn init_schema(&self) -> Result<()> {
        // Create events table with same schema as Go version
        query(r#"
            CREATE TABLE IF NOT EXISTS events (
                id TEXT PRIMARY KEY,
                pubkey TEXT NOT NULL,
                created_at INTEGER NOT NULL,
                kind INTEGER NOT NULL,
                tags TEXT NOT NULL,
                content TEXT NOT NULL,
                sig TEXT NOT NULL,
                group_name TEXT,
                stored_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        "#).execute(&self.pool).await
            .with_context(|| "Failed to create events table")?;

        // Create performance indexes
        query("CREATE INDEX IF NOT EXISTS idx_events_pubkey ON events(pubkey)").execute(&self.pool).await?;
        query("CREATE INDEX IF NOT EXISTS idx_events_created_at ON events(created_at)").execute(&self.pool).await?;
        query("CREATE INDEX IF NOT EXISTS idx_events_kind ON events(kind)").execute(&self.pool).await?;
        query("CREATE INDEX IF NOT EXISTS idx_events_group_name ON events(group_name)").execute(&self.pool).await?;
        query("CREATE INDEX IF NOT EXISTS idx_events_stored_at ON events(stored_at)").execute(&self.pool).await?;

        Ok(())
    }

    pub async fn store(&self, event: &Event, group_name: Option<String>) -> Result<()> {
        let tags_json = serde_json::to_string(&event.tags)
            .with_context(|| "Failed to serialize event tags")?;

        query(r#"
            INSERT OR REPLACE INTO events
            (id, pubkey, created_at, kind, tags, content, sig, group_name, stored_at)
            VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, datetime('now'))
        "#)
        .bind(event.id.to_hex())
        .bind(event.pubkey.to_hex())
        .bind(event.created_at.as_secs() as i64)
        .bind(event.kind.as_u16() as i64)
        .bind(tags_json)
        .bind(&event.content)
        .bind(event.sig.to_string())
        .bind(&group_name)
        .execute(&self.pool)
        .await
        .with_context(|| format!("Failed to store event: {}", event.id))?;

        Ok(())
    }

    pub async fn has(&self, event_id: &EventId) -> Result<bool> {
        let count: i64 = query("SELECT COUNT(*) as count FROM events WHERE id = ?1")
            .bind(event_id.to_hex())
            .fetch_one(&self.pool)
            .await?
            .get("count");

        Ok(count > 0)
    }

    pub async fn get(&self, event_id: &EventId) -> Result<Option<CachedEvent>> {
        let row = query(r#"
            SELECT id, pubkey, created_at, kind, tags, content, sig, group_name, stored_at
            FROM events WHERE id = ?1
        "#)
        .bind(event_id.to_hex())
        .fetch_optional(&self.pool)
        .await?;

        if let Some(row) = row {
            Ok(Some(CachedEvent {
                id: row.get("id"),
                pubkey: row.get("pubkey"),
                created_at: row.get("created_at"),
                kind: row.get::<i64, _>("kind") as u16,
                tags: row.get("tags"),
                content: row.get("content"),
                sig: row.get("sig"),
                group_name: row.get("group_name"),
                stored_at: row.get("stored_at"),
            }))
        } else {
            Ok(None)
        }
    }

    pub async fn query(
        &self,
        group: Option<&str>,
        author: Option<&PublicKey>,
        since: Option<i64>,
        limit: Option<i64>,
    ) -> Result<Vec<CachedEvent>> {
        let mut sql = String::from("SELECT id, pubkey, created_at, kind, tags, content, sig, group_name, stored_at FROM events WHERE 1=1");
        let mut params: Vec<String> = Vec::new();

        if let Some(group) = group {
            sql.push_str(&format!(" AND group_name = ?{}", params.len() + 1));
            params.push(group.to_string());
        }

        if let Some(author) = author {
            sql.push_str(&format!(" AND pubkey = ?{}", params.len() + 1));
            params.push(author.to_hex());
        }

        if let Some(since) = since {
            sql.push_str(&format!(" AND created_at >= ?{}", params.len() + 1));
            params.push(since.to_string());
        }

        sql.push_str(" ORDER BY created_at DESC");

        if let Some(limit) = limit {
            sql.push_str(&format!(" LIMIT ?{}", params.len() + 1));
            params.push(limit.to_string());
        }

        let mut query = query(&sql);
        for param in params {
            query = query.bind(param);
        }

        let rows = query.fetch_all(&self.pool).await?;
        let mut events = Vec::new();

        for row in rows {
            events.push(CachedEvent {
                id: row.get("id"),
                pubkey: row.get("pubkey"),
                created_at: row.get("created_at"),
                kind: row.get::<i64, _>("kind") as u16,
                tags: row.get("tags"),
                content: row.get("content"),
                sig: row.get("sig"),
                group_name: row.get("group_name"),
                stored_at: row.get("stored_at"),
            });
        }

        Ok(events)
    }

    pub async fn cleanup(&self, retention_days: u32) -> Result<u64> {
        if retention_days == 0 {
            return Ok(0); // No cleanup if retention is 0
        }

        let result = query("DELETE FROM events WHERE stored_at < datetime('now', '-' || ?1 || ' days')")
            .bind(retention_days as i64)
            .execute(&self.pool)
            .await?;

        Ok(result.rows_affected())
    }

    pub async fn stats(&self) -> Result<CacheStats> {
        // Total events
        let total: i64 = query("SELECT COUNT(*) as count FROM events")
            .fetch_one(&self.pool)
            .await?
            .get("count");

        // By kind
        let kind_rows = query("SELECT kind, COUNT(*) as count FROM events GROUP BY kind")
            .fetch_all(&self.pool)
            .await?;

        let mut by_kind = std::collections::HashMap::new();
        for row in kind_rows {
            let kind: i64 = row.get("kind");
            let count: i64 = row.get("count");
            by_kind.insert(kind as u16, count);
        }

        // By group
        let group_rows = query("SELECT group_name, COUNT(*) as count FROM events WHERE group_name IS NOT NULL GROUP BY group_name")
            .fetch_all(&self.pool)
            .await?;

        let mut by_group = std::collections::HashMap::new();
        for row in group_rows {
            let group: String = row.get("group_name");
            let count: i64 = row.get("count");
            by_group.insert(group, count);
        }

        // Recent 24h
        let recent_24h: i64 = query("SELECT COUNT(*) as count FROM events WHERE stored_at > datetime('now', '-1 day')")
            .fetch_one(&self.pool)
            .await?
            .get("count");

        Ok(CacheStats {
            total_events: total,
            by_kind,
            by_group,
            recent_24h,
        })
    }

    pub async fn get_recent_authors(&self, hours: i64) -> Result<Vec<String>> {
        let rows = query(r#"
            SELECT DISTINCT pubkey FROM events
            WHERE stored_at > datetime('now', '-' || ?1 || ' hours')
        "#)
        .bind(hours)
        .fetch_all(&self.pool)
        .await?;

        let mut authors = Vec::new();
        for row in rows {
            authors.push(row.get("pubkey"));
        }

        Ok(authors)
    }

    pub async fn has_by_hex(&self, event_id: &str) -> Result<bool> {
        let count: i64 = query("SELECT COUNT(*) as count FROM events WHERE id = ?1")
            .bind(event_id)
            .fetch_one(&self.pool)
            .await?
            .get("count");
        Ok(count > 0)
    }

    pub async fn store_raw(
        &self, id: &str, pubkey: &str, created_at: i64, kind: i64,
        tags: &str, content: &str, sig: &str, group_name: Option<&str>,
    ) -> Result<()> {
        query(r#"
            INSERT OR IGNORE INTO events
            (id, pubkey, created_at, kind, tags, content, sig, group_name, stored_at)
            VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, datetime('now'))
        "#)
        .bind(id).bind(pubkey).bind(created_at).bind(kind)
        .bind(tags).bind(content).bind(sig).bind(group_name)
        .execute(&self.pool).await?;
        Ok(())
    }

    pub async fn vacuum(&self) -> Result<()> {
        query("VACUUM").execute(&self.pool).await?;
        Ok(())
    }
}